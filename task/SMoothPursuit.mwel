
/* smooth pursuit training
 to teach monkeys physics around turnpoints

  1) straight fall (random horizontal position)
  2) right/left turn
  3) T-junction
  4) cross function

  - add path guides
  - change color when fixating
  - speed: 15-30 dva/sec (Lisberger)
  - play sound at turnpoints
  - id_turn: 3/4 for right/left T-junction, 5 for cross (0 for no turn, 1/2 for right/left,)

  (TBD)
  - change initial positions
      - random reward (or around turn?)

  2022/6/25:
    1) debug reward for id_turn=5
    2) remove id_turn=0,3,4
  2022/6/26
   - staircase of ball opacity
  2022/6/29
   - rotation generalization: id_rotate=0, 1(-90 deg), 2(90 deg)
  2022/7/13
    - mix visible & invisible trials randomly (id_visible)
    - implement 2-turns

    - (can be done) resume id_turn=3/4 for right-facing,left-facing T-junction; && id_turn!=3 && id_turn!=4
  2022/7/15
    - new set but now only with 1 turn (id_turn=5)
    - generalization plan ([id_turn id_rotate id_arm])
        1) [5 0/1/2 1/2]
        2) [1 0 1]: 2-turn
        3) [2 0 1]: mirror of 2)
        4) [1 1/2 1] [2 1/2 1]: +/- 90 deg rotation
        5) [1 0/1/2 2] [2 0/1/2 2]:ã„·
        6) 180 deg rotation: not implemented yet

    2022/7/19
    - turn off random selection of visible (H skipped invisible trials)
    - turn on staircase

    2022/7/26
    - feedback for incorrect: show moving ball but in red
    - set up id_turn id_arm id_rotate for generalization test

  (TBD)

    - choice version (rewarded if choose correct exit)


   */


///////////////////////////////////////////////////////////////////////////////
//
// I/O Devices
//
///////////////////////////////////////////////////////////////////////////////

// Include one of the following hand interfaces:

// %include 'hand_interfaces/keyboard' // debug
// %include 'hand_interfaces/gamepad'
// %include 'hand_interfaces/joystick'
%include 'hand_interfaces/joystick_monkey' // debug


// Include one of the following eye interfaces

// %include 'eye_interfaces/mouse' // debug
%include 'eye_interfaces/eyelink' // debug

// %include 'firmata_ephys' // debug
%include 'firmata_train'

// fake monkey: not used
/*
    fake_monkey fake_monkey (
    autostart = true
    ) {
   iochannel/eye_movement (
        eye_h = eye_x
        eye_v = eye_y
        data_interval = 1ms
        update_interval = 10ms
        )
    iochannel/juice (
        variable=reward_line
        )
    }
*/

///////////////////////////////////////////////////////////////////////////////
//
// Choose platform
//
///////////////////////////////////////////////////////////////////////////////
// var platform = 'monkey_ephys'
var platform = 'monkey_train'
// var platform = 'psychophysics'
// var platform = 'laptop'
// var platform = 'desktop'

///////////////////////////////////////////////////////////////////////////////
//
// Set data file, pwd, and python_site_packages
//
///////////////////////////////////////////////////////////////////////////////


var pwd = ""
var python_site_packages = ""
python_file ('set_pwd.py')

data_file ("$pwd/logs/$(date('%Y_%m_%d'))/mworks/$(date('%Y_%m_%d_%H_%M_%S'))")

///////////////////////////////////////////////////////////////////////////////
//
// Resources
//
///////////////////////////////////////////////////////////////////////////////

// These directories are copied to the machine running MWServer
resource ('sounds')

// These files are copied to the machine running MWServer and executed when the
// experiment loads
// python_file ('calibration_static.py')
// python_file ('task.py')

///////////////////////////////////////////////////////////////////////////////
//
// Sounds
//
///////////////////////////////////////////////////////////////////////////////

// These directories are copied to the machine running MWServer
resource ('sounds')

//sound/wav_file success_sound ('sounds/success.wav')
//sound/wav_file failure_sound ('sounds/failure.wav')
//sound/wav_file pong_sound ('sounds/pong.wav')

sound/wav_file pong_sound(
    path='sounds/pong.wav'
)

///////////////////////////////////////////////////////////////////////////////
//
// Variables
//
///////////////////////////////////////////////////////////////////////////////

    // var space_pressed = 0 (groups = I/O)

var data_file = ""
var tmp=0

group Reward {
    var reward_line = 0 (groups = Reward)
    var rewardDur = 50 (groups = Reward)
    var bonusRewDur = 0  (groups = Reward)
}
group Fixation {
    var fixY = 0 (groups = Fixation)
    var fixX = 0 (groups = Fixation)

    var amp_fixX = 8
    var amp_fixY = 8

    var fix_win = 10 (
        groups = Fixation
        persistant = 1
        )
    var fix_sz = 0.5 (groups = Fixation)
    var NoFixWaitDur = 2000 (groups = Fixation)
    var fixWaitDur = 10000 (groups = Fixation)
    var fixOn = 0 (groups = Fixation)

    var fix_red = 0 (groups = Fixation)
    var fix_green = 0.75 (groups = Fixation)
    var fix_blue = 0 (groups = Fixation)

    var fix_red_static = 1  (groups = Fixation)
    var fix_green_static = 0 (groups = Fixation)
    var fix_blue_static = 0 (groups = Fixation)

    var var_debug = 0 (groups = Fixation)
}


group Global {
    var pstop = 0 (groups = Trial)
    var startTrial = 0 (groups = Trial)
    var endTrial = 0 (groups = Trial)
    var localTrials = 0 (groups = Trial)
    var CorrectTrials = 0 (groups = Trial)
    var CorrectInvisibleTrials = 0 (groups = Trial)
}
group 'Fixation+Pursuit' {
    var pursuitTheta = -90 (groups = Fixation) // down; if 0, horizontal
    var nRep = 1 (groups = Fixation) // 3
    var trialNum = 1e6  (groups = Fixation) // after this # trials, stop experiment
    var on_fix_dyn = 0 (groups = Fixation)
    var on_fix_static = 0 (groups = Fixation)
    var fixHz = 0.25 (groups = Fixation) // not used; old
    var fixDynMag = 8 (groups = Fixation) // not used; old
    var tStart = 0 (groups = Fixation)
    var fix_pur_HoldDur = 2500 (groups = Fixation) // not used; old
    var fix_pur_ITI_Dur = 500 (groups = Fixation)
    var fix_pur_timeoutDur = 1500 (groups = Fixation)
}

group Matlab {
    var sync = 0 (groups = Matlab)
    var Nback = 100 (
        groups = Matlab
        persistant = 1
        )
}

group Time {
    //time stamps for eye movement analysis
    var tMazeOn = 0
    var tFix = 0
    var tBallOn = 0
    var tTurn = 0
    var tTurn_2 = 0
    var tRew = 0

    var t_static_fix = 500
    var tNow=0
}

group Maze {
    var id_turn=0 // 0 for no turn, 1/2 for right/left, 3/4 for right/left T-junction, 5 for cross
    var x_turn=0
    var y_turn=0
    var amp_y_turn=6
    var tmp_seg_length = 5
    var ball_speed=10 // 15

    var path_red = 0.5
    var path_green = 0.5
    var path_blue = 0.5

    var path_width = 0.6

    var x_size_h=0
    var y_size_h=0
    var x_position_h=0
    var y_position_h=0
    var x_size_v=0
    var y_size_v=0
    var x_position_v=0
    var y_position_v=0

    var dur_before_turn =0
    var dur_post_turn=0
    var dur_post_turn_2=0
    var id_bad = 0 // 1 if aborted during ball on; 2 postTurn; 3 postTurn2

    var id_rotate = 0 // id_rotate=0, 1(-90 deg), 2(90 deg)

    var id_arm=0 // 1 or 2 for arm added
    var x_turn2=0
    var y_turn2=0

    var x_size_3=0
    var y_size_3=0
    var x_position_3=0
    var y_position_3=0
}


group Staircase {
    var fix_alpha_max = 1
    var t_visible = 0.5 // sec; alpha linearly decrease from max to min
    var fix_alpha_min = 1 // 0.3 // 0 // 0.5
    var fix_alpha_min0 = 0// 0.5
    var fix_alpha_min_feedback = 0 // if 1, visible feedback; if 0, invisible
    var id_visible = 0
    var p_visible = 0 // 0.333

    var delta_fix_alpha_up = 0 //  0.1 // 0.01 // 0 // 0.01
    var delta_fix_alpha_down = 0 // 0.5 // 0.05 // 0 // 0.05
}

///////////////////////////////////////////////////////////////////////////////
//
// Stimuli
//
///////////////////////////////////////////////////////////////////////////////


group 'path' {
    stimulus/rectangle horizon_path(
        color = path_red, path_green, path_blue
        x_size=x_size_h
        y_size=y_size_h
        x_position=x_position_h
        y_position=y_position_h
    )
    stimulus/rectangle vertical_path(
        color = path_red, path_green, path_blue
        x_size=x_size_v
        y_size=y_size_v
        x_position=x_position_v
        y_position=y_position_v
    )
    stimulus/rectangle arm(
        color = path_red, path_green, path_blue
        x_size=x_size_3
        y_size=y_size_3
        x_position=x_position_3
        y_position=y_position_3
    )
}

group 'Fixation+Pursuit 2' {
    frame_list dynamicFix (
        stimulus_group = dynamicFixFrames
        loop = YES // NO // YES
        autoplay = YES // NO //YES
        )
    stimulus_group dynamicFixFrames {
        circular_fixation_point fixCircleDyn (
            color = fix_red,fix_green,fix_blue
            trigger_width = fix_win
            trigger_watch_x = eye_x
            trigger_watch_y = eye_y
            trigger_flag = on_fix_dyn
            x_size = fix_sz
            y_size = fix_sz
            x_position = fixX+cos(pursuitTheta*pi()/180)*ball_speed*(next_frame_time() - tStart)/1e6 // set up for 1s drift to right most point (8deg)
            y_position = fixY+sin(pursuitTheta*pi()/180)*ball_speed*(next_frame_time() - tStart)/1e6
            // x_position = fixX+cos(pursuitTheta*pi()/180)*fixDynMag*sin(2*pi()*fixHz*(next_frame_time() - tStart)/1e6) // set up for 1s drift to right most point (8deg)
            // y_position = fixY+sin(pursuitTheta*pi()/180)*fixDynMag*sin(2*pi()*fixHz*(next_frame_time() - tStart)/1e6)
            rotation = 0
            alpha_multiplier = max(fix_alpha_min,fix_alpha_max-(fix_alpha_max-fix_alpha_min)/t_visible*((next_frame_time() - tBallOn)/1e6))
            )
    }

    stimulus/circular_fixation_point fixCircleStatic (
            color = fix_red_static,fix_green_static,fix_blue_static
            trigger_width = fix_win
            trigger_watch_x = eye_x
            trigger_watch_y = eye_y
            trigger_flag = on_fix_static
            x_size = fix_sz
            y_size = fix_sz
            x_position = fixX
            y_position = fixY
            rotation = 0
            alpha_multiplier = 1
    )
}


iodevice/stimulus_display( // % distance 66, width 53, height 30 cm -> atand(height/2/distance)*2; % 25.6 deg
    background_color = 0,0,0
    )

///////////////////////////////////////////////////////////////////////////////
//
// Sampling trials
//
///////////////////////////////////////////////////////////////////////////////

% define sample_visiblity ()

if_else{
    if (rand() > p_visible){
        id_visible = 0
        fix_alpha_min = fix_alpha_min0 // comment to use staircase

    }
    else {
            id_visible = 1
            // fix_alpha_min0 = fix_alpha_min // keeping staircase (debug TBD)
            fix_alpha_min = 1
        }
    }

% end

%define sample_trial ()

            sample_visiblity ()

            // sample locations
            x_turn=rand(-amp_fixX,amp_fixX)
            y_turn=rand(-amp_y_turn,0)

            // set fixations
            fixX=x_turn
            fixY=amp_fixY

            // set initial path
            x_size_v=path_width
            y_size_v= amp_fixY-y_turn
            x_position_v=x_turn
            y_position_v= amp_fixY-(y_size_v/2)

            id_turn=disc_rand(0,5)
            // selecting only 1 2 5
            while (id_turn!=1 && id_turn!=2){ // && id_turn!=1 && id_turn!=2 && id_turn!=3 && id_turn!=4
                id_turn=disc_rand(0,5)
            }
            // id_turn=disc_rand(0,4)
            // id_turn=disc_rand(0,2)

            // arm
            id_arm = 1 // disc_rand(1, 2) // for now, always add 3rd arm

            if (id_turn==0){ // no turn
                x_size_h=0
                y_size_h=0
                x_position_h=0
                y_position_h=0
            }
            if (id_turn==1){ // right turn
                x_size_h=tmp_seg_length
                y_size_h=path_width
                x_position_h=x_turn+tmp_seg_length/2-path_width/2
                y_position_h=y_turn

                // arm
                x_turn2=x_turn+x_size_h
                y_turn2=y_turn
                if (id_arm==1){ // down
                    x_size_3=path_width
                    y_size_3=tmp_seg_length
                    x_position_3=x_turn2
                    y_position_3=y_turn2-y_size_3/2+path_width/2
                }
                if (id_arm==2){ // up
                    x_size_3=path_width
                    y_size_3=tmp_seg_length
                    x_position_3=x_turn2
                    y_position_3=y_turn2+y_size_3/2-path_width/2
                }
            }
            if (id_turn==2){ // left turn
                x_size_h=tmp_seg_length
                y_size_h=path_width
                x_position_h=x_turn-tmp_seg_length/2+path_width/2
                y_position_h=y_turn

                // arm
                x_turn2=x_turn-x_size_h
                y_turn2=y_turn
                if (id_arm==1){ // down
                    x_size_3=path_width
                    y_size_3=tmp_seg_length
                    x_position_3=x_turn2
                    y_position_3=y_turn2-y_size_3/2+path_width/2
                }
                if (id_arm==2){ // up
                    x_size_3=path_width
                    y_size_3=tmp_seg_length
                    x_position_3=x_turn2
                    y_position_3=y_turn2+y_size_3/2-path_width/2
                }
            }
            if (id_turn==3){ // T-junction with right
                x_size_h=tmp_seg_length
                y_size_h=path_width
                x_position_h=x_turn+tmp_seg_length/2-path_width/2
                y_position_h=y_turn

                y_size_v= amp_fixY*2
                y_position_v= 0
            }
            if (id_turn==4){ // T-junction with left
                x_size_h=tmp_seg_length
                y_size_h=path_width
                x_position_h=x_turn-tmp_seg_length/2+path_width/2
                y_position_h=y_turn

                y_size_v= amp_fixY*2
                y_position_v= 0
            }
            if (id_turn==5){ // cross junction
                x_size_h=tmp_seg_length*2
                y_size_h=path_width
                x_position_h=x_turn
                y_position_h=y_turn

                y_size_v= amp_fixY*2
                y_position_v= 0

                // arm
                x_turn2=x_turn
                y_turn2=-amp_fixY
                if (id_arm==1){ // left
                    x_size_3=tmp_seg_length
                    y_size_3=path_width
                    x_position_3=x_turn2-x_size_3/2+path_width/2
                    y_position_3=y_turn2
                }
                if (id_arm==2){ // right
                    x_size_3=tmp_seg_length
                    y_size_3=path_width
                    x_position_3=x_turn2+x_size_3/2-path_width/2
                    y_position_3=y_turn2
                }
            }

            if (id_turn==3 || id_turn==4 || id_turn==5){
                dur_before_turn = (amp_fixY-y_turn)/ball_speed // seconds
                dur_post_turn = (2*amp_fixY-(amp_fixY-y_turn))/ball_speed // seconds; x_size_h=0 for id_turn=0

                dur_post_turn_2 = x_size_3/ball_speed
            }

            if (id_turn==0 || id_turn==1 || id_turn==2){
                dur_before_turn = y_size_v/ball_speed // seconds
                dur_post_turn = x_size_h/ball_speed // seconds; x_size_h=0 for id_turn=0

                dur_post_turn_2 = y_size_3/ball_speed
            }

%end

% define random_rotate ()
    id_rotate=0 // disc_rand(0,2) // id_rotate=0, 1(-90 deg), 2(90 deg)

    if (id_rotate == 1){ // x=-y y=x
        pursuitTheta=0

        tmp=x_turn
        x_turn=-y_turn
        y_turn=tmp

        tmp=fixX
        fixX=-fixY
        fixY=tmp

        tmp=x_size_v
        x_size_v=y_size_h
        y_size_h=tmp

        tmp=x_size_h
        x_size_h=y_size_v
        y_size_v=tmp

        tmp=y_position_v
        y_position_v=x_position_h
        x_position_h=-tmp

        tmp=x_position_v
        x_position_v=-y_position_h
        y_position_h=tmp

        //arm
        tmp=x_turn2
        x_turn2=-y_turn2
        y_turn2=tmp

        tmp=x_size_3
        x_size_3=y_size_3
        y_size_3=tmp

        tmp=y_position_3
        y_position_3=x_position_3
        x_position_3=-tmp
    }

    if (id_rotate == 2){ // x=y y=-x
        pursuitTheta=180

        tmp=x_turn
        x_turn=y_turn
        y_turn=-tmp

        tmp=fixX
        fixX=fixY
        fixY=-tmp

        tmp=x_size_v
        x_size_v=y_size_h
        y_size_h=tmp

        tmp=y_size_v
        y_size_v=x_size_h
        x_size_h=tmp

        tmp=x_position_v
        x_position_v=y_position_h
        y_position_h=-tmp

        tmp=x_position_h
        x_position_h=y_position_v
        y_position_v=-tmp

        //arm
        tmp=x_turn2
        x_turn2=y_turn2
        y_turn2=-tmp

        tmp=x_size_3
        x_size_3=y_size_3
        y_size_3=tmp

        tmp=y_position_3
        y_position_3=-x_position_3
        x_position_3=tmp

    }
% end

% define update_fixation_postturn ()
        tNow = now()

        // turn: reset fixX fixY tStart
        fixX=fixX+cos(pursuitTheta*pi()/180)*ball_speed*(tNow - tStart)/1e6
        fixY=fixY+sin(pursuitTheta*pi()/180)*ball_speed*(tNow - tStart)/1e6
        tStart = now()

        if (id_rotate == 0){
            // pursuitTheta: -90 for down, 0/180 for right/left
            if (id_turn==1){ // right turn
                pursuitTheta=0
            }
            if (id_turn==2){ // left turn
                pursuitTheta=180
            }
        }

        if (id_rotate == 1){ // x=-y y=x
            // pursuitTheta: -90 for down, 0/180 for right/left
            if (id_turn==1){ // right turn
                pursuitTheta=90
            }
            if (id_turn==2){ // left turn
                pursuitTheta=-90
            }

        }

        if (id_rotate == 2){ // x=y y=-x
            // pursuitTheta: -90 for down, 0/180 for right/left
            if (id_turn==1){ // right turn
                pursuitTheta=-90
            }
            if (id_turn==2){ // left turn
                pursuitTheta=90
            }
        }
% end

% define update_fixation_postturn_2 ()
        tNow = now()

        // turn: reset fixX fixY tStart
        fixX=fixX+cos(pursuitTheta*pi()/180)*ball_speed*(tNow - tStart)/1e6
        fixY=fixY+sin(pursuitTheta*pi()/180)*ball_speed*(tNow - tStart)/1e6
        tStart = now()

        // pursuitTheta: -90 for down, 0/180 for right/left

        if (id_turn == 5){
            if (id_arm==1){
                if (id_rotate==0){
                    pursuitTheta=180
                } // L
                if (id_rotate==1){
                    pursuitTheta=-90
                } // D
                if (id_rotate==2){
                    pursuitTheta=90
                } // U
            }
            if (id_arm==2){
                if (id_rotate==0){
                    pursuitTheta=0
                } // R
                if (id_rotate==1){
                    pursuitTheta=90
                } // U
                if (id_rotate==2){
                    pursuitTheta=-90
                } // D
            }
        }

        if (id_turn == 1){
            if (id_arm==1){
                if (id_rotate==0){
                    pursuitTheta=-90
                } // D
                if (id_rotate==1){
                    pursuitTheta=0
                } // R
                if (id_rotate==2){
                    pursuitTheta=180
                } // L
            }
            if (id_arm==2){
                if (id_rotate==0){
                    pursuitTheta=90
                } // U
                if (id_rotate==1){
                    pursuitTheta=180
                } // L
                if (id_rotate==2){
                    pursuitTheta=0
                } // R
            }

        }

        if (id_turn == 2){
            if (id_arm==1){
                if (id_rotate==0){
                    pursuitTheta=-90
                } // D
                if (id_rotate==1){
                    pursuitTheta=0
                } // R
                if (id_rotate==2){
                    pursuitTheta=180
                } // L
            }
            if (id_arm==2){
                if (id_rotate==0){
                    pursuitTheta=90
                } // U
                if (id_rotate==1){
                    pursuitTheta=180
                } // L
                if (id_rotate==2){
                    pursuitTheta=0
                } // R
            }
        }



% end

///////////////////////////////////////////////////////////////////////////////
//
// Protocols
//
///////////////////////////////////////////////////////////////////////////////


protocol 'Pursuit' {
    start_device_io (eye_tracker)

    start_io_device (firmata) // debug

    update_stimulus_display ()
    task Trials {
        state 'Initial' {
            localTrials = 0
            CorrectTrials = 0
            CorrectInvisibleTrials = 0

            sample_trial ()

            random_rotate ()

            goto ('Fix On')
        }
        state 'Fix On' {

            //MATLAB
            sync=0
            sync=1

            tMazeOn = now()

            queue_stimulus(horizon_path)
            queue_stimulus(vertical_path)
            queue_stimulus(arm)
            queue_stimulus(fixCircleStatic)

            update_stimulus_display ()

            /*
            fake_monkey_fixate(
                fake_monkey=fake_monkey
                duration=500*1e3 // microsec
            )
            fake_monkey_saccade_and_fixate(
                fake_monkey=fake_monkey
                h=fixX
                v=fixY
                duration=600*1e3 // microsec
            )*/

            start_timer (
                timer = fixWait
                duration = fixWaitDur // 10000
                duration_units = ms
                )
            goto (
                target = 'Static Fix'
                when = on_fix_static
                )
            timer_expired (
                target = 'Failure to fixate'
                timer = fixWait
                )
        }

        state 'Static Fix' {
            tFix = now()
            fix_green_static = .75
            fix_red_static = 0
            update_stimulus_display ()

            start_timer (
                timer = StaticFixWait
                duration = t_static_fix // 500
                duration_units = ms
                )
            goto (
                target = 'Failure to fixate'
                when = !on_fix_static
                )
            timer_expired (
                target = 'Ball On'
                timer = StaticFixWait
                )

        }

        state 'Ball On' {
            report ('Ball On')
            tBallOn = now()

            dequeue_stimulus(fixCircleStatic)
            tStart = next_frame_time()
            live_queue_stimulus (dynamicFix)
            update_stimulus_display ()

            // var_debug = cos(pursuitTheta*pi()/180)*ball_speed*(next_frame_time() - tStart)/1e6

            // play_dynamic_stimulus (dynamicFix)


            startTrial = 1
            start_timer (
                timer = timer_ball_on
                duration = dur_before_turn*1e3 // fix_pur_HoldDur 2500
                duration_units = ms
                )
            goto (
                target = 'Bad Ball On'
                when = !on_fix_dyn
                )
            timer_expired (
                target = 'Postturn'
                timer = timer_ball_on
                )
        }
        state 'Bad Ball On' {
            report('Bad Ball On')
            fix_red = 1
            fix_green = 0
            fix_alpha_min = fix_alpha_min_feedback
            id_bad = 1
            goto (
                target = 'Postturn'
                when = timerExpired(timer_ball_on)
                )
        }

        state 'Postturn' {
            report ('Postturn')
            tTurn = now()

            if (id_turn==1 || id_turn==2){ // (id_turn!=0){
                play_sound(pong_sound)
            }
            update_fixation_postturn ()

            start_timer (
                timer = timer_postturn
                duration = dur_post_turn*1e3 // fix_pur_HoldDur 2500
                duration_units = ms
                )
            goto (
                target = 'Bad Postturn'
                when = !on_fix_dyn
                )
            timer_expired (
                target = 'Postturn2' // 'Reward'
                timer = timer_postturn
                )
        }

        state 'Bad Postturn' {
            report('Bad Postturn')
            fix_red = 1
            fix_green = 0
            fix_alpha_min = fix_alpha_min_feedback
            id_bad = 2
            goto (
                target = 'Postturn2'
                when = timerExpired(timer_postturn)
                )
        }

        state 'Postturn2' {
            report ('Postturn2')
            tTurn_2 = now()

            if (id_turn==1 || id_turn==2 || id_turn==5){ // (id_turn!=0){
                play_sound(pong_sound)
            }
            update_fixation_postturn_2 ()

            start_timer (
                timer = timer_postturn2
                duration = dur_post_turn_2*1e3 // fix_pur_HoldDur 2500
                duration_units = ms
                )
            goto (
                target = 'Bad Postturn2'
                when = !on_fix_dyn
                )
            goto (
                target = 'Reward'
                when = id_bad ==0 && timerExpired(timer_postturn2)
                )
            goto (
                target = 'Bad'
                when = id_bad !=0 && timerExpired(timer_postturn2)
                )
        }

        state 'Bad Postturn2' {
            report('Bad Postturn2')
            fix_red = 1
            fix_green = 0
            fix_alpha_min = fix_alpha_min_feedback
            id_bad = 3
            goto (
                target = 'Bad'
                when = timerExpired(timer_postturn2)
                )
        }

        state 'Reward' {
            report ('Success!')

            tRew = now()

            dequeue_stimulus (dynamicFix)

            CorrectTrials = CorrectTrials+1
            if (id_visible==0){
                CorrectInvisibleTrials=CorrectInvisibleTrials+1
            }

            fix_green = 1

            // keep ball at the end of path
            fix_green_static = 1
            fix_red_static = 0
            fixX=fixX+cos(pursuitTheta*pi()/180)*ball_speed*(now() - tStart)/1e6
            fixY=fixY+sin(pursuitTheta*pi()/180)*ball_speed*(now() - tStart)/1e6
            queue_stimulus(fixCircleStatic)

            update_stimulus_display ()

            //staircase
            fix_alpha_min=max(0,fix_alpha_min-delta_fix_alpha_down)

            pulse ( // micro seconds
                variable = reward_line
                duration = (rewardDur+bonusRewDur)*1000
                )
            start_timer (
                timer = GreenTime
                duration = rewardDur+bonusRewDur
                duration_units = ms
                )
            timer_expired (
                target = 'End Trial'
                timer = GreenTime
                )
        }
        state 'End Trial' {
            report ('Ending Trial.')
            fix_green = 0.75
            fix_red = 0

            fix_green_static = 0
            fix_red_static = 1
            dequeue_stimulus (dynamicFix)
            dequeue_stimulus (fixCircleStatic)

            // dequeue_stimulus(horizon_path)
            // dequeue_stimulus(vertical_path)

            update_stimulus_display ()

            localTrials = localTrials+1
            endTrial = 1
            goto (
                target = 'Exit Fixation Pursuit System'
                when = CorrectTrials >= trialNum
                )
            goto (
                target = 'Exit Fixation Pursuit System'
                when = pstop
                )
            goto (ITI)
        }
        state ITI {
            report ('ITI.')

            pursuitTheta = -90

            sample_trial ()

            random_rotate ()

            start_timer (
                timer = fix_pur_ITI
                duration = fix_pur_ITI_Dur // 500
                duration_units = ms
                )
            timer_expired (
                target = 'Fix On'
                timer = fix_pur_ITI
                )
        }
        state Bad {
            report ('Trial Failed.')

            //staircase
            fix_alpha_min=min(1,fix_alpha_min+delta_fix_alpha_up)

            dequeue_stimulus (dynamicFix)

            // keep ball at the end of path
            fix_green_static = 0
            fix_red_static = 1
            fixX=fixX+cos(pursuitTheta*pi()/180)*ball_speed*(now() - tStart)/1e6
            fixY=fixY+sin(pursuitTheta*pi()/180)*ball_speed*(now() - tStart)/1e6
            queue_stimulus(fixCircleStatic)

            update_stimulus_display ()

            start_timer (
                timer = fix_pur_timeout
                duration = fix_pur_timeoutDur // 1500
                duration_units = ms
                )
            timer_expired (
                target = 'End Trial'
                timer = fix_pur_timeout
                )
        }

        state 'Failure to fixate' {
            report ('Failure to fixate.')
            dequeue_stimulus (dynamicFix)
            update_stimulus_display ()
            start_timer (
                timer = NoFixWait
                duration = NoFixWaitDur  // 2000
                duration_units = ms
                )
            timer_expired (
                target = 'Fix On'
                timer = NoFixWait
                )
        }
        state 'Exit Fixation Pursuit System' {
            report ('Leaving state system')
            yield ()
        }
    }
}
