///////////////////////////////////////////////////////////////////////////////
//
// Choose interface to use
//
///////////////////////////////////////////////////////////////////////////////

// Include one of the following controller interfaces:

// %include 'controller_interfaces/keyboard'
// %include 'controller_interfaces/gamepad_grid'
// %include 'controller_interfaces/gamepad'
// %include 'controller_interfaces/joystick_grid'
%include 'controller_interfaces/joystick'


// Include one of the following eye interfaces

// %include 'eye_interfaces/mouse'
%include 'eye_interfaces/eyelink'


///////////////////////////////////////////////////////////////////////////////
//
// Set data file, pwd, and python_site_packages
//
///////////////////////////////////////////////////////////////////////////////


var pwd = ""
var python_site_packages = ""
python_file ('set_pwd.py')

data_file ("$pwd/logs/$(date('%Y_%m_%d'))/mworks/$(date('%Y_%m_%d_%H_%M_%S'))")


///////////////////////////////////////////////////////////////////////////////
//
// Resources
//
///////////////////////////////////////////////////////////////////////////////

// These directories are copied to the machine running MWServer
resource ('sounds')

// These files are copied to the machine running MWServer and executed when the
// experiment loads
python_file ('calibration_static.py')
python_file ('task.py')


///////////////////////////////////////////////////////////////////////////////
//
// Stimuli
//
///////////////////////////////////////////////////////////////////////////////


var image_pixel_width = 512
var image_pixel_height = 512
var image_size_x = 20
var image_size_y = 20
var image_pos_x = 0
var image_pos_y = 0

stimulus/python_image image (
    pixel_buffer_format = 'RGB8'
    pixel_buffer_width = image_pixel_width
    pixel_buffer_height = image_pixel_height
    pixel_buffer_expr = 't.step()'
    x_size = image_size_x
    y_size = image_size_y
    x_position = image_pos_x
    y_position = image_pos_y
    )


///////////////////////////////////////////////////////////////////////////////
//
// Sounds
//
///////////////////////////////////////////////////////////////////////////////


wav_file success_sound ('sounds/success.wav')
wav_file failure_sound ('sounds/failure.wav')


///////////////////////////////////////////////////////////////////////////////
//
// Variables
//
///////////////////////////////////////////////////////////////////////////////


var data_file = ""

var end_task = False
var end_trial = False
var task_error = False

var reward_duration = 0
var reward_line = false
var inter_trial_interval_duration = 0s
var default_iti = 0s

// For mapping eye tracker coordinates to positions on the image frame
var eye_to_frame_coeffs = [[0, 0], [0, 0]]
var eye_to_frame_intercept = [0, 0]


///////////////////////////////////////////////////////////////////////////////
//
// Shared Task Protocol Body
//
///////////////////////////////////////////////////////////////////////////////


%define run_task ()
    report ('********    STARTING TASK    ********')
    end_task = false
    task_error = false

    trial {
        task {
            state 'Begin trial' {
                report('****  BEGINNING TRIAL  ****')
                run_python_string ('t.reset()')

                reward_duration = 0

                // It's not strictly necessary to start and stop the I/O devices
                // every trial (i.e. you could just start them once at the
                // beginning of the protocol), but doing so ensures that the
                // Python code receives joystick and eye tracking events only
                // while a trial is active
                start_io_device (eye_tracker)
                start_io_device (controller)

                queue_stimulus (image)
                update_display ()

                goto ('Wait for completion')
            }

            state 'Wait for completion' {
                goto (
                    target = 'Success'
                    when = reward_duration > 0
                    )
                goto (
                    target = 'Failure'
                    when = reward_duration < 0
                    )
                goto (
                    target = 'End trial'
                    when = end_trial
                    )
                goto (
                    target = 'End protocol'
                    when = end_task
                    )
                goto (
                    target = 'Task error'
                    when = task_error
                    )
            }

            state 'Success' {
                play_sound (success_sound)
                goto ('Reward')
            }

            state 'Reward' {
                report ('Dispensing reward for $(reward_duration / 1000) ms')

                // In a real experiment, reward_line could control a digital
                // output on a NIDAQ or other device
                reward_line = true
                wait (reward_duration)
                reward_line = false
                reward_duration = 0

                goto ('Wait for completion')
            }

            state 'Failure' {
                play_sound (failure_sound)
                reward_duration = 0
                
                goto ('Wait for completion')
            }

            state 'End trial' {
                report('****  ENDING TRIAL  ****')
                
                stop_io_device (eye_tracker)
                stop_io_device (controller)
                
                end_trial = false
                clear_display ()

                start_timer (
                    timer = timer
                    duration = inter_trial_interval_duration
                    )

                goto (
                    target = 'Begin trial'
                    when = timer_expired(timer)
                    )
            }

            state 'End protocol' {
                report ('********    ENDING TASK    ********')
                inter_trial_interval_duration = default_iti
                yield ()
            }

            state 'Task error' {
                report ('********    TASK ERROR    ********')
                goto ('End protocol')
            }
        }
    }
%end


///////////////////////////////////////////////////////////////////////////////
//
// Eye Calibration Setup Protocol
//
///////////////////////////////////////////////////////////////////////////////


protocol 'Eye Calibration' {
    // inter_trial_interval_duration = 0s
    run_python_string ('t = CalibrationManager(grid_size=3)')
    run_task ()
}


///////////////////////////////////////////////////////////////////////////////
//
// Task Protocols
//
///////////////////////////////////////////////////////////////////////////////

// Deterministic

protocol 'p_occ_top.v0' {
    run_python_string (
        't = TaskManager(level="p_occ_top.v0.v0", delay_phase=False, fixation_phase=False)')
    run_task ()
}

// Memorization

protocol 'ps_occ_bottom.mem_v1' {
    run_python_string (
        't = TaskManager(level="ps_occ_bottom.mem_v1.mem_v1", delay_phase=False, fixation_phase=False)')
    run_task ()
}

protocol 'ps_occ_bottom.mem_v0' {
    run_python_string (
        't = TaskManager(level="ps_occ_bottom.mem_v0.mem_v0", delay_phase=False, fixation_phase=False)')
    run_task ()
}

protocol 'ps_occ_bottom.mem_v2' {
    run_python_string (
        't = TaskManager(level="ps_occ_bottom.mem_v2.mem_v2", delay_phase=False, fixation_phase=False)')
    run_task ()
}

// Exclusion

protocol 'ps_occ_top.exclusion_v1' {
    run_python_string (
        't = TaskManager(level="ps_occ_top.exclusion_v1.exclusion_v1", delay_phase=False, fixation_phase=False)')
    run_task ()
}

// Multi-split

protocol 'pss_occ_top.no_merge_v0' {
    run_python_string (
        't = TaskManager(level="pss_occ_top.no_merge_v0.no_merge_v0", delay_phase=False, fixation_phase=False)')
    run_task ()
}

protocol 'pss_occ_top.merge_v0' {
    run_python_string (
        't = TaskManager(level="pss_occ_top.merge_v0.merge_v0", delay_phase=False, fixation_phase=False)')
    run_task ()
}

protocol 'pss_occ_top.high_merge_v0' {
    run_python_string (
        't = TaskManager(level="pss_occ_top.high_merge_v0.high_merge_v0", delay_phase=False, fixation_phase=False)')
    run_task ()
}

// Two prey split control

protocol 'psps_occ_top.split_control_v0' {
    run_python_string (
        't = TaskManager(level="psps_occ_top.split_control_v0.split_control_v0", delay_phase=False, fixation_phase=False)')
    run_task ()
}




// Experiments


protocol 'experiments_p.exp_v0' {
    run_python_string (
        't = TaskManager(level="experiments_p.exp_v0.exp_v0", delay_phase=True, fixation_phase=False)')
    run_task ()
}

protocol 'experiments_pp.exp_v0' {
    run_python_string (
        't = TaskManager(level="experiments_pp.exp_v0.exp_v0", delay_phase=True, fixation_phase=False)')
    run_task ()
}

protocol 'random.exp_1_prey translucent' {
    run_python_string (
        't = TaskManager(level="random.exp_1_prey.exp_1_prey", delay_phase=True, translucent_occluder=True, fixation_phase=False)')
    run_task ()
}

protocol 'random.exp_2_prey translucent' {
    run_python_string (
        't = TaskManager(level="random.exp_2_prey.exp_2_prey", delay_phase=True, translucent_occluder=True, fixation_phase=False)')
    run_task ()
}

protocol 'random.exp_1_prey' {
    run_python_string (
        't = TaskManager(level="random.exp_1_prey.exp_1_prey", delay_phase=True, fixation_phase=False)')
    run_task ()
}

protocol 'random.exp_2_prey' {
    run_python_string (
        't = TaskManager(level="random.exp_2_prey.exp_2_prey", delay_phase=True, fixation_phase=False)')
    run_task ()
}

